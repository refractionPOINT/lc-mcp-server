package http

import (
	"bytes"
	"context"
	"encoding/json"
	"log/slog"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/refractionpoint/lc-mcp-go/internal/auth"
	"github.com/refractionpoint/lc-mcp-go/internal/config"
	"github.com/refractionpoint/lc-mcp-go/internal/tools"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// MockRedisClient implements a mock Redis client for testing
type MockRedisClient struct {
	pingErr    error
	getFunc    func(ctx context.Context, key string) (string, error)
	setFunc    func(ctx context.Context, key string, value string, expiration time.Duration) error
	deleteFunc func(ctx context.Context, key string) error
	closeFunc  func() error
}

func (m *MockRedisClient) Ping(ctx context.Context) error {
	return m.pingErr
}

func (m *MockRedisClient) Get(ctx context.Context, key string) (string, error) {
	if m.getFunc != nil {
		return m.getFunc(ctx, key)
	}
	return "", assert.AnError
}

func (m *MockRedisClient) Set(ctx context.Context, key string, value string, expiration time.Duration) error {
	if m.setFunc != nil {
		return m.setFunc(ctx, key, value, expiration)
	}
	return nil
}

func (m *MockRedisClient) Delete(ctx context.Context, key string) error {
	if m.deleteFunc != nil {
		return m.deleteFunc(ctx, key)
	}
	return nil
}

func (m *MockRedisClient) Close() error {
	if m.closeFunc != nil {
		return m.closeFunc()
	}
	return nil
}

// MockTokenManager implements a mock token manager for testing
type MockTokenManager struct {
	validateFunc func(ctx context.Context, token string, checkExpiry bool) (*token.ValidationResult, error)
}

func (m *MockTokenManager) ValidateAccessToken(ctx context.Context, accessToken string, checkExpiry bool) (*token.ValidationResult, error) {
	if m.validateFunc != nil {
		return m.validateFunc(ctx, accessToken, checkExpiry)
	}
	return &token.ValidationResult{
		Valid:            true,
		UID:              "test-uid",
		LimaCharlieJWT:   "test-jwt",
		FirebaseIDToken:  "test-firebase-token",
	}, nil
}

// createTestServer creates a minimal server for testing
// Note: This is simplified for basic route testing. Full integration tests
// would require more complex setup with actual Redis and OAuth mocking.
func createTestServer(t *testing.T) *Server {
	t.Helper()

	logger := slog.Default()
	cfg := &config.Config{
		HTTP: config.HTTPConfig{
			Port: 8080,
		},
	}

	// Create SDK cache
	sdkCache := auth.NewSDKCache(5*time.Minute, logger)

	// Create mock Redis client
	mockRedis := &MockRedisClient{
		pingErr: nil, // Default healthy
	}

	s := &Server{
		config:      cfg,
		logger:      logger,
		mux:         http.NewServeMux(),
		redisClient: mockRedis,
		sdkCache:    sdkCache,
		profile:     "core", // Default test profile
	}

	// Setup routes
	s.setupRoutes()

	return s
}

// Test Health Endpoint
func TestHealthEndpoint(t *testing.T) {
	server := createTestServer(t)

	req := httptest.NewRequest(http.MethodGet, "/health", nil)
	w := httptest.NewRecorder()

	server.mux.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)

	var response map[string]interface{}
	err := json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err)

	assert.Equal(t, "healthy", response["status"])
	assert.NotEmpty(t, response["time"])
}

// Test Ready Endpoint
func TestReadyEndpoint(t *testing.T) {
	t.Run("returns ready when Redis is available", func(t *testing.T) {
		mockRedis := &MockRedisClient{
			pingErr: nil, // Redis is healthy
		}
		server := createTestServer(t)

		req := httptest.NewRequest(http.MethodGet, "/ready", nil)
		w := httptest.NewRecorder()

		server.mux.ServeHTTP(w, req)

		assert.Equal(t, http.StatusOK, w.Code)

		var response map[string]interface{}
		err := json.Unmarshal(w.Body.Bytes(), &response)
		require.NoError(t, err)

		assert.Equal(t, "ready", response["status"])
		checks := response["checks"].(map[string]interface{})
		assert.True(t, checks["redis"].(bool))
	})

	t.Run("returns not ready when Redis is unavailable", func(t *testing.T) {
		mockRedis := &MockRedisClient{
			pingErr: assert.AnError, // Redis is down
		}
		server := createTestServer(t)

		req := httptest.NewRequest(http.MethodGet, "/ready", nil)
		w := httptest.NewRecorder()

		server.mux.ServeHTTP(w, req)

		assert.Equal(t, http.StatusServiceUnavailable, w.Code)

		var response map[string]interface{}
		err := json.Unmarshal(w.Body.Bytes(), &response)
		require.NoError(t, err)

		assert.Equal(t, "not_ready", response["status"])
		checks := response["checks"].(map[string]interface{})
		assert.False(t, checks["redis"].(bool))
	})
}

// Test MCP Initialize Method
func TestMCPInitialize(t *testing.T) {
	server := createTestServer(t)

	requestBody := map[string]interface{}{
		"jsonrpc": "2.0",
		"id":      1,
		"method":  "initialize",
		"params": map[string]interface{}{
			"protocolVersion": "2024-11-05",
			"clientInfo": map[string]interface{}{
				"name":    "test-client",
				"version": "1.0.0",
			},
		},
	}

	body, err := json.Marshal(requestBody)
	require.NoError(t, err)

	req := httptest.NewRequest(http.MethodPost, "/mcp", bytes.NewReader(body))
	req.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()

	server.mux.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)

	var response map[string]interface{}
	err = json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err)

	assert.Equal(t, "2.0", response["jsonrpc"])
	assert.Equal(t, float64(1), response["id"])

	result := response["result"].(map[string]interface{})
	assert.Equal(t, "2024-11-05", result["protocolVersion"])
	assert.NotNil(t, result["capabilities"])
	assert.NotNil(t, result["serverInfo"])

	serverInfo := result["serverInfo"].(map[string]interface{})
	assert.Equal(t, "LimaCharlie MCP Server", serverInfo["name"])
}

// Test MCP Tools List
func TestMCPToolsList(t *testing.T) {
	server := createTestServer(t)

	requestBody := map[string]interface{}{
		"jsonrpc": "2.0",
		"id":      1,
		"method":  "tools/list",
		"params":  map[string]interface{}{},
	}

	body, err := json.Marshal(requestBody)
	require.NoError(t, err)

	req := httptest.NewRequest(http.MethodPost, "/mcp", bytes.NewReader(body))
	req.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()

	server.mux.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)

	var response map[string]interface{}
	err = json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err)

	assert.Equal(t, "2.0", response["jsonrpc"])
	result := response["result"].(map[string]interface{})
	toolsList := result["tools"].([]interface{})

	// Should have at least some core tools
	assert.Greater(t, len(toolsList), 0)

	// Check that tools have required fields
	if len(toolsList) > 0 {
		firstTool := toolsList[0].(map[string]interface{})
		assert.NotEmpty(t, firstTool["name"])
		assert.NotEmpty(t, firstTool["description"])
		assert.NotNil(t, firstTool["inputSchema"])
	}
}

// Test Invalid JSON-RPC Request
func TestInvalidJSONRPC(t *testing.T) {
	server := createTestServer(t)

	t.Run("malformed JSON", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodPost, "/mcp", bytes.NewReader([]byte("invalid json")))
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()

		server.mux.ServeHTTP(w, req)

		assert.Equal(t, http.StatusOK, w.Code) // JSON-RPC errors still return 200

		var response map[string]interface{}
		err := json.Unmarshal(w.Body.Bytes(), &response)
		require.NoError(t, err)

		errorObj := response["error"].(map[string]interface{})
		assert.Equal(t, float64(-32700), errorObj["code"]) // Parse error
	})

	t.Run("invalid JSON-RPC version", func(t *testing.T) {
		requestBody := map[string]interface{}{
			"jsonrpc": "1.0", // Wrong version
			"id":      1,
			"method":  "initialize",
		}

		body, err := json.Marshal(requestBody)
		require.NoError(t, err)

		req := httptest.NewRequest(http.MethodPost, "/mcp", bytes.NewReader(body))
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()

		server.mux.ServeHTTP(w, req)

		var response map[string]interface{}
		err = json.Unmarshal(w.Body.Bytes(), &response)
		require.NoError(t, err)

		errorObj := response["error"].(map[string]interface{})
		assert.Equal(t, float64(-32600), errorObj["code"]) // Invalid Request
	})

	t.Run("unknown method", func(t *testing.T) {
		requestBody := map[string]interface{}{
			"jsonrpc": "2.0",
			"id":      1,
			"method":  "unknown_method",
			"params":  map[string]interface{}{},
		}

		body, err := json.Marshal(requestBody)
		require.NoError(t, err)

		req := httptest.NewRequest(http.MethodPost, "/mcp", bytes.NewReader(body))
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()

		server.mux.ServeHTTP(w, req)

		var response map[string]interface{}
		err = json.Unmarshal(w.Body.Bytes(), &response)
		require.NoError(t, err)

		errorObj := response["error"].(map[string]interface{})
		assert.Equal(t, float64(-32601), errorObj["code"]) // Method not found
	})
}

// Test Missing Authorization
func TestMissingAuth(t *testing.T) {
	server := createTestServer(t)

	requestBody := map[string]interface{}{
		"jsonrpc": "2.0",
		"id":      1,
		"method":  "tools/call",
		"params": map[string]interface{}{
			"name":      "test_tool",
			"arguments": map[string]interface{}{},
		},
	}

	body, err := json.Marshal(requestBody)
	require.NoError(t, err)

	req := httptest.NewRequest(http.MethodPost, "/mcp", bytes.NewReader(body))
	req.Header.Set("Content-Type", "application/json")
	// No Authorization header
	w := httptest.NewRecorder()

	server.mux.ServeHTTP(w, req)

	var response map[string]interface{}
	err = json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err)

	errorObj := response["error"].(map[string]interface{})
	assert.Equal(t, float64(-32000), errorObj["code"]) // Server error
	assert.Contains(t, errorObj["message"], "Unauthorized")
}

// Test Invalid Bearer Token Format
func TestInvalidBearerToken(t *testing.T) {
	server := createTestServer(t)

	t.Run("missing Bearer prefix", func(t *testing.T) {
		requestBody := map[string]interface{}{
			"jsonrpc": "2.0",
			"id":      1,
			"method":  "tools/call",
			"params": map[string]interface{}{
				"name":      "test_tool",
				"arguments": map[string]interface{}{},
			},
		}

		body, err := json.Marshal(requestBody)
		require.NoError(t, err)

		req := httptest.NewRequest(http.MethodPost, "/mcp", bytes.NewReader(body))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Authorization", "invalid-token") // Missing "Bearer " prefix
		w := httptest.NewRecorder()

		server.mux.ServeHTTP(w, req)

		var response map[string]interface{}
		err = json.Unmarshal(w.Body.Bytes(), &response)
		require.NoError(t, err)

		errorObj := response["error"].(map[string]interface{})
		assert.Equal(t, float64(-32000), errorObj["code"])
		assert.Contains(t, errorObj["message"], "Unauthorized")
	})
}

// Test Root Endpoint
func TestRootEndpoint(t *testing.T) {
	server := createTestServer(t)

	t.Run("GET returns server info", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, "/", nil)
		w := httptest.NewRecorder()

		server.mux.ServeHTTP(w, req)

		assert.Equal(t, http.StatusOK, w.Code)

		var response map[string]interface{}
		err := json.Unmarshal(w.Body.Bytes(), &response)
		require.NoError(t, err)

		assert.Equal(t, "lc-mcp-server", response["type"])
		assert.Equal(t, "ok", response["status"])
		assert.NotNil(t, response["endpoints"])
	})

	t.Run("POST delegates to MCP handler", func(t *testing.T) {
		requestBody := map[string]interface{}{
			"jsonrpc": "2.0",
			"id":      1,
			"method":  "ping",
		}

		body, err := json.Marshal(requestBody)
		require.NoError(t, err)

		req := httptest.NewRequest(http.MethodPost, "/", bytes.NewReader(body))
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()

		server.mux.ServeHTTP(w, req)

		assert.Equal(t, http.StatusOK, w.Code)

		var response map[string]interface{}
		err = json.Unmarshal(w.Body.Bytes(), &response)
		require.NoError(t, err)

		assert.Equal(t, "2.0", response["jsonrpc"])
	})

	t.Run("other methods return 405", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodPut, "/", nil)
		w := httptest.NewRecorder()

		server.mux.ServeHTTP(w, req)

		assert.Equal(t, http.StatusMethodNotAllowed, w.Code)
	})
}

// Test Method Not Allowed
func TestMethodNotAllowed(t *testing.T) {
	server := createTestServer(t)

	req := httptest.NewRequest(http.MethodGet, "/mcp", nil)
	w := httptest.NewRecorder()

	server.mux.ServeHTTP(w, req)

	assert.Equal(t, http.StatusMethodNotAllowed, w.Code)
}

// Test Ping Method
func TestPingMethod(t *testing.T) {
	server := createTestServer(t)

	requestBody := map[string]interface{}{
		"jsonrpc": "2.0",
		"id":      1,
		"method":  "ping",
	}

	body, err := json.Marshal(requestBody)
	require.NoError(t, err)

	req := httptest.NewRequest(http.MethodPost, "/mcp", bytes.NewReader(body))
	req.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()

	server.mux.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)

	var response map[string]interface{}
	err = json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err)

	assert.Equal(t, "2.0", response["jsonrpc"])
	assert.Equal(t, float64(1), response["id"])
	assert.NotNil(t, response["result"])
}

// Test Profile Selection
func TestProfileSelection(t *testing.T) {
	server := createTestServer(t)

	// Test with explicit profile set
	server.profile = "core"

	req := httptest.NewRequest(http.MethodGet, "/historical_data", nil)
	activeProfile := server.getActiveProfile(req)

	// Should use explicit profile, not URL
	assert.Equal(t, "core", activeProfile)

	// Test with no explicit profile (URL-based routing)
	server.profile = ""

	req = httptest.NewRequest(http.MethodGet, "/historical_data", nil)
	activeProfile = server.getActiveProfile(req)

	// Should extract from URL
	assert.Equal(t, "historical_data", activeProfile)
}

// Test Tool Registration
func TestToolRegistration(t *testing.T) {
	// Verify that core tools are registered
	coreTools := []string{
		"test_tool",
		"get_sensor_info",
		"list_sensors",
		"get_online_sensors",
		"is_online",
		"search_hosts",
	}

	for _, toolName := range coreTools {
		tool, ok := tools.GetTool(toolName)
		assert.True(t, ok, "Tool %s should be registered", toolName)
		if ok {
			assert.Equal(t, toolName, tool.Name)
			assert.NotEmpty(t, tool.Description)
			assert.NotNil(t, tool.Handler)
		}
	}
}

// Test StateManager Integration
func TestStateManagerIntegration(t *testing.T) {
	mockRedis := &MockRedisClient{
		setFunc: func(ctx context.Context, key string, value string, expiration time.Duration) error {
			return nil
		},
		getFunc: func(ctx context.Context, key string) (string, error) {
			return "test-value", nil
		},
	}

	logger := slog.Default()

	// Create a minimal encryption mock (nil is acceptable for this test)
	stateManager := state.NewManager(mockRedis, nil, logger)

	assert.NotNil(t, stateManager)
}

// Test Token Manager Integration
func TestTokenManagerIntegration(t *testing.T) {
	logger := slog.Default()

	stateManager := state.NewManager(mockRedis, nil, logger)

	// Mock Firebase client would be needed here for full integration
	// For now, just verify the structure
	assert.NotNil(t, stateManager)
}

// Test Server Close
func TestServerClose(t *testing.T) {
	closeCalled := false
	mockRedis := &MockRedisClient{
		closeFunc: func() error {
			closeCalled = true
			return nil
		},
	}
	server := createTestServer(t)

	err := server.Close()

	assert.NoError(t, err)
	assert.True(t, closeCalled, "Redis close should be called")
}

// Benchmark MCP Request Handling
func BenchmarkMCPInitialize(b *testing.B) {
	server := createTestServer(&testing.T{}, mockRedis, mockToken)

	requestBody := map[string]interface{}{
		"jsonrpc": "2.0",
		"id":      1,
		"method":  "initialize",
		"params":  map[string]interface{}{},
	}

	body, _ := json.Marshal(requestBody)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		req := httptest.NewRequest(http.MethodPost, "/mcp", bytes.NewReader(body))
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()
		server.mux.ServeHTTP(w, req)
	}
}
